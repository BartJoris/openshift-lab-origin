= HyperShift Setup for ACM 2.7

== Overview

This document describes how to install and configure Hypershift from scratch. It also explains how to deploy a managed cluster using Hypershift.

This document is not part of the lab (the environment has been pre-provisioned) but rather is provided as background information to explain what has been set up.

== Docs

* RHACM 2.5: https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.5/html/clusters/managing-your-clusters#hosted-control-plane-intro
* RHACM 2.6: https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html/multicluster_engine/multicluster_engine_overview#hosted-control-planes-intro
* RHACM 2.7: https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.7/html/multicluster_engine/multicluster_engine_overview#hosted-control-planes-intro


== Prerequisites

. Deploy an OpenShift 4.12 (RC) cluster
. On that cluster install Advanced Cluster Manager 2.7 (operator and operand)
* For beta/upstream code deploy as outlined in https://github.com/stolostron/deploy
. Get your AWS credentials ready
* AWS Access Key
* AWS Secret Access Key
* Top level domain (sandboxXXXX.opentlc.com)
. Retrieve your privae and public key (e.g. ~/.ssh/${GUID}key.pem and ~/.ssh/${GUID}key.pub)
. Make sure you have your OpenShift Pull Secret in a file `$HOME/pullsecret.json`

=== Set up the Hypershift CLI

. Install make
+
[source,sh]
----
sudo dnf -y install make
----

. Download and install the `yq` binary
+
[source,sh]
----
sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
sudo chmod +x /usr/bin/yq
----

. Install go
+
[source,sh]
----
wget https://go.dev/dl/go1.18.10.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.18.10.linux-amd64.tar.gz
rm go1.18.10.linux-amd64.tar.gz
echo "export PATH=$PATH:/usr/local/go/bin" >>~/.bashrc
source ~/.bashrc
----

. Download, build and install the Hypershift CLI
+
[source,sh]
----
git clone https://github.com/openshift/hypershift.git
cd hypershift
make hypershift
sudo install -m 0755 bin/hypershift /usr/bin/hypershift
----

=== Deploy Open Cluster Management

. Clone the repo
+
[source,sh]
----
git clone https://github.com/stolostron/deploy.git
----

. Generate your `~/deploy/prereqs/pull-secret.yaml` as per https://github.com/stolostron/deploy#prepare-to-deploy-open-cluster-management-instance-only-do-once

. Install Open Cluster Management
+
[source,sh]
----
cd ~/deploy
./start.sh --watch --search
----

. Use a recent 2.7 Snapshot from https://quay.io/repository/stolostron/acm-custom-registry?tab=tags (e.g. `2.7.0-SNAPSHOT-2023-01-10-16-43-48`) when prompted.

. Wait for the install to finish.

=== Set up AWS

. Set up AWS Credentials in file `~/.aws/credentials`
+
[source,texinfo]
----
[default]
aws_access_key_id = YOUR_AWS_ACCESS_KEY_ID
aws_secret_access_key = YOUR_AWS_SECRET_ACCESS_KEY
----

=== Setup Hypershift

. Hypershift needs an AWS S3 Bucket to store OICD documents (although Minio or OpenShift Data Foundations should work as well).
+
. Create an AWS S3 Bucket:
+
[source,sh]
----
aws s3api create-bucket \
  --bucket oidc-storage-${GUID} \
  --region us-east-2 \
  --create-bucket-configuration LocationConstraint=us-east-2
----
. Create a secret with AWS credential information in the `local-cluster` namespace:
+
[source,sh]
----
oc create secret generic hypershift-operator-oidc-provider-s3-credentials \
  -n local-cluster \
  --from-file=credentials=$HOME/.aws/credentials \
  --from-literal=bucket=oidc-storage-${GUID} \
  --from-literal=region=us-east-2

oc label secret hypershift-operator-oidc-provider-s3-credentials \
  -n local-cluster \
  cluster.open-cluster-management.io/backup=true
----

. Enable the HyperShift Preview Tech Preview:
+
[source,sh]
----
oc patch mce multiclusterengine \
  -n multicluster-engine \
  --type=merge \
  --patch '{"spec":{"overrides":{"components":[{"name":"hypershift-preview","enabled": true}]}}}'
----

. Wait for the Hypershift addon to be installed:
+
[source,sh]
----
oc wait --for=condition=Degraded=True managedclusteraddons/hypershift-addon -n local-cluster --timeout=5m
oc wait --for=condition=Available=True managedclusteraddons/hypershift-addon -n local-cluster --timeout=5m
----

. Validate that the addon is available:
+
[source,sh]
----
oc get managedclusteraddon hypershift-addon -n local-cluster
----
+
.Sample Output
[source,texinfo]
----
NAME               AVAILABLE   DEGRADED   PROGRESSING
hypershift-addon   True        False
----

Your Red Hat Advanced Cluster Management for Kubernetes is now configured for the Hypershift Tech Preview.

== Deploy a Hosted Cluster using the hypershift CLI (All in one)

Using the `hypershift` CLI you can now deploy a hosted cluster.

. Setup environment variables to deploy a cluster *development-${GUID}* in region us-west-2.
+
[source,sh]
----
export REGION=us-west-2
export CLUSTER_NAME=development-${GUID}
export INFRA_ID=development-${GUID}
export BASE_DOMAIN=sandbox948.opentlc.com
export PULL_SECRET=${HOME}/pullsecret.json
export BUCKET_NAME=oidc-storage-${GUID}
export BUCKET_REGION=us-east-2
export AWS_CREDS_FILE=${HOME}/.aws/credentials
----

. Create the hosted cluster:
+
[source,sh]
----
hypershift create cluster aws \
    --name ${CLUSTER_NAME} \
    --infra-id ${INFRA_ID} \
    --pull-secret ${PULL_SECRET} \
    --aws-creds ${AWS_CREDS_FILE} \
    --region ${REGION} \
    --zones ${REGION}a \ # Single zone setup, can add more zones \
    --instance-type m6a.2xlarge \ # Default is m5.large which is usually too small \
    --root-volume-type gp3 \
    --root-volume-size 250 \
    --base-domain ${BASE_DOMAIN} \
    --generate-ssh \
    --control-plane-availability-policy SingleReplica \ # HighlyAvailable
    --network-type OVNKubernetes \ # Calico, OVNKubernetes, OpenShiftSDN
    --release-image quay.io/openshift-release-dev/ocp-release:4.12.0-x86_64 \ # optional, if omitted same as hub cluster
    --node-pool-replicas 2 \
    --namespace clusters


hypershift create cluster aws \
    --name ${CLUSTER_NAME} \
    --infra-id ${INFRA_ID} \
    --pull-secret ${PULL_SECRET} \
    --aws-creds ${AWS_CREDS_FILE} \
    --region ${REGION} \
    --zones ${REGION}a \
    --instance-type m6a.2xlarge \
    --root-volume-type gp3 \
    --root-volume-size 250 \
    --base-domain ${BASE_DOMAIN} \
    --generate-ssh \
    --control-plane-availability-policy SingleReplica \
    --network-type OVNKubernetes \
    --release-image quay.io/openshift-release-dev/ocp-release:4.12.0-x86_64 \
    --node-pool-replicas 2 \
    --namespace clusters

export CLUSTER_NAME=production-${GUID}
export INFRA_ID=production-${GUID}
hypershift create cluster aws \
    --name ${CLUSTER_NAME} \
    --infra-id ${INFRA_ID} \
    --pull-secret ${PULL_SECRET} \
    --aws-creds ${AWS_CREDS_FILE} \
    --region ${REGION} \
    --zones ${REGION}a \
    --instance-type m6a.2xlarge \
    --root-volume-type gp3 \
    --root-volume-size 250 \
    --base-domain ${BASE_DOMAIN} \
    --generate-ssh \
    --control-plane-availability-policy SingleReplica \
    --network-type OVNKubernetes \
    --release-image quay.io/openshift-release-dev/ocp-release:4.12.0-x86_64 \
    --node-pool-replicas 2 \
    --namespace clusters
----

. Wait until hosted cluster is available
+
[source,sh]
----
oc get hostedclusters -n ${CLUSTER_NAME}
----
+
.Sample Output
[source,texinfo,options=nowrap]
----
NAME                VERSION   KUBECONFIG                           PROGRESS   AVAILABLE   PROGRESSING   MESSAGE
development-wk412             development-wk412-admin-kubeconfig   Partial    True        False         The hosted control plane is available
----

. Check MachineSets for hosted cluster (and wait until all replicas are ready and available):
+
[source,sh]
----
oc get machineset.cluster -A
----
+
.Sample Output
[source,texinfo]
----
NAMESPACE                         NAME                                      CLUSTER             REPLICAS   READY   AVAILABLE   AGE     VERSION
local-cluster-development-wk412   development-wk412-us-west-2a-5454cdd59b   development-wk412   2                              3m54s   4.12.0-rc.8
----

. You can also check the Machines:
+
[source,sh]
----
oc get machine.cluster -A
----
+
.Sample Output
[source,texinfo]
----
NAMESPACE                         NAME                                            CLUSTER             NODENAME   PROVIDERID   PHASE          AGE     VERSION
local-cluster-development-wk412   development-wk412-us-west-2a-5454cdd59b-6xz9t   development-wk412                           Provisioning   4m43s   4.12.0-rc.8
local-cluster-development-wk412   development-wk412-us-west-2a-5454cdd59b-zdpk4   development-wk412                           Provisioning   4m43s   4.12.0-rc.8
----

== Deploy a Hosted Cluster using the hypershift CLI (individual steps)

Using the `hypershift` CLI you can now deploy a hosted cluster.

. Set some environment variables to deploy a cluster *development* in region us-west-2.
+
[source,sh]
----
export OCP_RELEASE_IMAGE=quay.io/openshift-release-dev/ocp-release:4.12.0-x86_64
export REGION=us-west-2
export CLUSTER_NAME=development-${GUID}
export INFRA_ID=development-${GUID}
export BASE_DOMAIN=sandbox948.opentlc.com
export PULL_SECRET=${HOME}/pullsecret.json
export BUCKET_NAME=oidc-storage-${GUID}
export BUCKET_REGION=us-east-2
export AWS_CREDS_FILE=${HOME}/.aws/credentials
export AWS_OUTPUT_FILE=${HOME}/aws-output.json
export AWS_IAM_OUTPUT_FILE=${HOME}/aws-iam-output.json
----

. Create the AWS infrastructure resources for the cluster:
+
[source,sh]
----
hypershift create infra aws \
  --aws-creds ${AWS_CREDS_FILE} \
  --base-domain ${BASE_DOMAIN} \
  --infra-id ${INFRA_ID} \
  --name ${CLUSTER_NAME} \
  --region ${REGION} \
  --output-file ${AWS_OUTPUT_FILE}
----

. Retrieve information from AWS outputfile and save as variables:
+
[source,sh]
----
export AWS_MACHINE_CIDR=$(cat ${AWS_OUTPUT_FILE} | jq '.machineCIDR' | tr -d '"')
export AWS_VPC_ID=$(cat ${AWS_OUTPUT_FILE} | jq '.vpcID' | tr -d '"')
export AWS_ZONE_NAME=$(cat ${AWS_OUTPUT_FILE} | jq '.zones[0] .name' | tr -d '"')
export AWS_ZONE_SUBNET_ID=$(cat ${AWS_OUTPUT_FILE} | jq '.zones[0] .subnetID' | tr -d '"')
export AWS_SECURITY_GROUP_ID=$(cat ${AWS_OUTPUT_FILE} | jq '.securityGroupID' | tr -d '"')
export AWS_PUBLIC_ZONE_ID=$(cat ${AWS_OUTPUT_FILE} | jq '.publicZoneID' | tr -d '"')
export AWS_PRIVATE_ZONE_ID=$(cat ${AWS_OUTPUT_FILE} | jq '.privateZoneID' | tr -d '"')
export AWS_LOCAL_ZONE_ID=$(cat ${AWS_OUTPUT_FILE} | jq '.localZoneID' | tr -d '"')
----

. Create AWS IAM resources:
+
[source,sh]
----
hypershift create iam aws \
  --aws-creds ${AWS_CREDS_FILE} \
  --infra-id ${INFRA_ID} \
  --local-zone-id ${AWS_LOCAL_ZONE_ID} \
  --private-zone-id ${AWS_PRIVATE_ZONE_ID} \
  --public-zone-id ${AWS_PUBLIC_ZONE_ID} \
  --oidc-storage-provider-s3-bucket-name ${BUCKET_NAME} \
  --oidc-storage-provider-s3-region ${BUCKET_REGION} \
  --output-file ${AWS_IAM_OUTPUT_FILE}
----

. Retrieve information from AWS IAM outputfile and save as variables:
+
[source,sh]
----
export AWS_IAM_PROFILE_NAME=$(cat ${AWS_IAM_OUTPUT_FILE} | jq '.profileName' | tr -d '"')
export AWS_IAM_ISSUER_URL=$(cat ${AWS_IAM_OUTPUT_FILE} | jq '.issuerURL' | tr -d '"')
export AWS_IAM_ROLES_INGRESS_ARN=$(cat ${AWS_IAM_OUTPUT_FILE} | jq '.roles .ingressARN' | tr -d '"')
export AWS_IAM_ROLES_IMG_REGISTRY_ARN=$(cat ${AWS_IAM_OUTPUT_FILE} | jq '.roles .imageRegistryARN' | tr -d '"')
export AWS_IAM_ROLES_STORAGE_ARN=$(cat ${AWS_IAM_OUTPUT_FILE} | jq '.roles .storageARN' | tr -d '"')
export AWS_IAM_ROLES_NETWORK_ARN=$(cat ${AWS_IAM_OUTPUT_FILE} | jq '.roles .networkARN' | tr -d '"')
export AWS_IAM_ROLES_KUBE_CLOUD_CONTROLLER_ARN=$(cat ${AWS_IAM_OUTPUT_FILE} | jq '.roles .kubeCloudControllerARN' | tr -d '"')
export AWS_IAM_ROLES_NODEPOOL_MGMT_ARN=$(cat ${AWS_IAM_OUTPUT_FILE} | jq '.roles .nodePoolManagementARN' | tr -d '"')
export AWS_IAM_ROLES_CPO_ARN=$(cat ${AWS_IAM_OUTPUT_FILE} | jq '.roles .controlPlaneOperatorARN' | tr -d '"')
----

. Either create the hosted cluster via CLI:
+
[source,sh]
----
hypershift create cluster aws \
  --name ${CLUSTER_NAME} \
  --infra-id ${INFRA_ID} \
  --infra-json ${AWS_OUTPUT_FILE} \
  --iam-json ${AWS_IAM_OUTPUT_FILE} \
  --aws-creds ${AWS_CREDS_FILE} \
  --pull-secret ${PULL_SECRET} \
  --region ${REGION} \
  --generate-ssh \
  --node-pool-replicas 3 \
  --namespace local-cluster

oc annotate hostedcluster development-${GUID} \
  -n local-cluster \
  cluster.open-cluster-management.io/hypershiftdeployment=local-cluster/${CLUSTER_NAME}

oc annotate hostedcluster development-${GUID} \
  -n local-cluster \
  cluster.open-cluster-management.io/managedcluster-name=${CLUSTER_NAME}
----

. Or create the hosted cluster via YAML:
+
[source,sh]
----
oc create secret generic -n local-cluster \
   ${CLUSTER_NAME}-pull-secret \
   --from-file=.dockerconfigjson=${PULL_SECRET}

oc create secret generic -n local-cluster \
  ${CLUSTER_NAME}-ssh-key \
  --from-file=id_rsa=${HOME}/.ssh/id_rsa \
  --from-file=id_rsa.pub=${HOME}/.ssh/id_rsa.pub

cat <<EOF >${HOME}/${CLUSTER_NAME}.yaml
---
apiVersion: hypershift.openshift.io/v1beta1
kind: HostedCluster
metadata:
  name: ${CLUSTER_NAME}
  namespace: local-cluster
  annotations:
    cluster.open-cluster-management.io/hypershiftdeployment: local-cluster/${CLUSTER_NAME}
    cluster.open-cluster-management.io/managedcluster-name: ${CLUSTER_NAME}
spec:
  autoscaling: {}
  controllerAvailabilityPolicy: SingleReplica
  dns:
    baseDomain: ${BASE_DOMAIN}
    privateZoneID: ${AWS_PRIVATE_ZONE_ID}
    publicZoneID: ${AWS_PUBLIC_ZONE_ID}
  etcd:
    managed:
      storage:
        persistentVolume:
          size: 4Gi
          storageClassName: gp3-csi
        type: PersistentVolume
    managementType: Managed
  fips: false
  infraID: ${INFRA_ID}
  infrastructureAvailabilityPolicy: SingleReplica
  issuerURL: https://${BUCKET_NAME}.s3.${BUCKET_REGION}.amazonaws.com/${CLUSTER_NAME}
  networking:
    clusterNetwork:
    - cidr: 10.132.0.0/14
    machineNetwork:
    - cidr: ${AWS_MACHINE_CIDR}
    networkType: OVNKubernetes
    serviceNetwork:
    - cidr: 172.31.0.0/16
  olmCatalogPlacement: management
  platform:
    aws:
      cloudProviderConfig:
        subnet:
          id: ${AWS_ZONE_SUBNET_ID}
        vpc: ${AWS_VPC_ID}
        zone: ${AWS_ZONE_NAME}
      endpointAccess: Public
      region: ${REGION}
      resourceTags:
      - key: kubernetes.io/cluster/${CLUSTER_NAME}
        value: owned
      rolesRef:
        controlPlaneOperatorARN: ${AWS_IAM_ROLES_CPO_ARN}
        imageRegistryARN: ${AWS_IAM_ROLES_IMG_REGISTRY_ARN}
        ingressARN: ${AWS_IAM_ROLES_INGRESS_ARN}
        kubeCloudControllerARN: ${AWS_IAM_ROLES_KUBE_CLOUD_CONTROLLER_ARN}
        networkARN: ${AWS_IAM_ROLES_NETWORK_ARN}
        nodePoolManagementARN: ${AWS_IAM_ROLES_NODEPOOL_MGMT_ARN}
        storageARN: ${AWS_IAM_ROLES_STORAGE_ARN}
    type: AWS
  pullSecret:
    name: ${CLUSTER_NAME}-pull-secret
  release:
    image: ${OCP_RELEASE_IMAGE}
  secretEncryption:
    aescbc:
      activeKey:
        name:  ${CLUSTER_NAME}-etcd-encryption-key
    type: aescbc
  services:
  - service: APIServer
    servicePublishingStrategy:
      type: LoadBalancer
  - service: OAuthServer
    servicePublishingStrategy:
      type: Route
  - service: Konnectivity
    servicePublishingStrategy:
      type: Route
  - service: Ignition
    servicePublishingStrategy:
      type: Route
  - service: OVNSbDb
    servicePublishingStrategy:
      type: Route
  sshKey:
    name: ${CLUSTER_NAME}-ssh-key
EOF
----

. Create the cluster:
+
[source,sh]
----
oc apply -f ${HOME}/${CLUSTER_NAME}.yaml
----

. Create a *NodePool* manifest:
+
[source,sh]
----
cat <<EOF >${HOME}/${CLUSTER_NAME}-node-pool.yaml
---
apiVersion: hypershift.openshift.io/v1beta1
kind: NodePool
metadata:
  name: ${CLUSTER_NAME}-workers
  namespace: local-cluster
spec:
  clusterName: ${CLUSTER_NAME}
  management:
    autoRepair: true
    replace:
      rollingUpdate:
        maxSurge: 1
        maxUnavailable: 0
      strategy: RollingUpdate
    upgradeType: Replace
  platform:
    aws:
      instanceProfile: ${INFRA_ID}-worker
      instanceType: m6a.2xlarge
      rootVolume:
        size: 120
        type: gp3
      securityGroups:
      - id: ${AWS_SECURITY_GROUP_ID}
      subnet:
        id: ${AWS_ZONE_SUBNET_ID}
    type: AWS
  release:
    image: ${OCP_RELEASE_IMAGE}
  replicas: 2
EOF
----

. Create the NodePool:
+
[source,sh]
----
oc apply -f ${HOME}/${CLUSTER_NAME}-node-pool.yaml
----

. Create *Managed Cluster* resource:
+
[source,sh]
----
cat <<EOF | oc apply -f -
apiVersion: cluster.open-cluster-management.io/v1
kind: ManagedCluster
metadata:
  annotations:
    import.open-cluster-management.io/hosting-cluster-name: local-cluster
    import.open-cluster-management.io/klusterlet-deploy-mode: Hosted
    open-cluster-management/created-via: other
  labels:
    cloud: auto-detect
    cluster.open-cluster-management.io/clusterset: default
    name: ${CLUSTER_NAME}
    vendor: OpenShift
    type: sandbox-development
  name: ${CLUSTER_NAME}
spec:
  hubAcceptsClient: true
  leaseDurationSeconds: 60
EOF
----

=== Import the cluster into RHACM

. Create *Managed Cluster* resource:
+
[source,sh]
----
cat <<EOF | oc apply -f -
apiVersion: cluster.open-cluster-management.io/v1
kind: ManagedCluster
metadata:
  annotations:
    import.open-cluster-management.io/hosting-cluster-name: local-cluster
    import.open-cluster-management.io/klusterlet-deploy-mode: Hosted
    open-cluster-management/created-via: other
  labels:
    cloud: auto-detect
    cluster.open-cluster-management.io/clusterset: default
    name: ${CLUSTER_NAME}
    vendor: OpenShift
    type: sandbox-development
  name: ${CLUSTER_NAME}
spec:
  hubAcceptsClient: true
  leaseDurationSeconds: 60
EOF
----

That's it. Your hosted cluster is now deployed.

=== Destroy Hosted Clusters manually in case of failure

. Destroy hosted cluster via CLI:
+
[source,sh]
----
hypershift destroy cluster aws \
  --name ${CLUSTER_NAME} \
  --infra-id ${INFRA_ID} \
  --aws-creds ${AWS_CREDS_FILE} \
  --namespace local-cluster
----

. Destroy AWS IAM resources:
+
[source,sh]
----
hypershift destroy iam aws --aws-creds ${AWS_CREDS_FILE} --infra-id ${INFRA_ID}
----

. Destroy AWS infrastructure resources:
+
[source,sh]
----
hypershift destroy infra aws --aws-creds ${AWS_CREDS_FILE} --base-domain ${BASE_DOMAIN} --infra-id ${INFRA_ID}
----










== Access cluster(s)

The kubeadmin password and kubeconfig file are stored in secrets in the `local-cluster`namespace.

* `<clustername>-kubeadmin-password`
* `<clustername>-admin-kubeconfig`

. Get the kubeadmin password:
+
[source,sh]
----
oc get secret ${CLUSTER_NAME}-kubeadmin-password -n local-cluster --template='{{ .data.password }}' | base64 -d ; echo
----

. Get the kubeconfig file and save it as `$HOME/kubeconfig-<clustername>.yaml`
+
[source,sh]
----
oc get secret ${CLUSTER_NAME}-admin-kubeconfig -n local-cluster --template='{{ .data.kubeconfig }}' | base64 -d >$HOME/kubeconfig-${CLUSTER_NAME}.yaml
----

. Set the KUBECONFIG variable to point to the new kube config file
+
[source,sh]
----
export KUBECONFIG=$HOME/kubeconfig-${CLUSTER_NAME}.yaml
----

. Validate the configuration
+
[source,sh]
----
oc get co
----

. Get the console URL
+
[source,sh]
----
oc whoami --show-console
----

. Log into the console using `kubeadmin` and the previously retrieved kubeadmin password.

. Unset the KUBECONFIG variable to work back on your local cluster.
+
[source,sh]
----
unset KUBECONFIG
----
